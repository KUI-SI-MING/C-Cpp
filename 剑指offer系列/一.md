@[toc]
##### 1.合并两个排序的链表
<font color=black size=3 face="微软雅黑">&emsp;&emsp;输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则
> <font color = black size = 3 face  = "微软雅黑">首先了解到的要点就是需要合并两个已经排序后的链表，因此就有两种选择：①创建第三条链表，同时对两条原始链表的元素从头开始进行比较然后将得到的元素压入新链表直到某一条链表结束，将剩下的链表接上即可②在两条原始链表的基础上进行元素的处理，即选择长链表作为最终返回值，将短链表中的元素压入长链表，处理好前后之间的关系即可
```cpp
/*
struct ListNode {
	int val;
	struct ListNode *next;
	ListNode(int x) :
			val(x), next(NULL) {
	}
};*/
class Solution {
public:
	ListNode* Merge(ListNode* pHead1, ListNode* pHead2)
	{
		ListNode* newlist;

		if (pHead1 == pHead2 || pHead2 == NULL)
		{
			return pHead1;//两条链表相同或者第二条链表为空
		}
		else if (pHead1 == NULL) {
			return pHead2;//第一条链表为空
		}
		else//两条链表都不为空
		{
			if (pHead1->val < pHead2->val)//第一条链表的值小于第二条链表的值
			{
				newlist = pHead1;//插入第一条链表的元素
				newlist->next = Merge(pHead1->next, pHead2);
			}
			else//第一条链表的值大于第二条链表的值
			{
				newlist = pHead2;//插入第二条链表的元素
				newlist->next = Merge(pHead1, pHead2->next);
			}
		}
		return newlist;
	}
};
```
> <font color = black size = 3 face  = "微软雅黑">链接：[合并两个排序的链表](https://www.nowcoder.com/practice/d8b6b4358f774294a89de2a6ac4d9337?tpId=13&tqId=11169&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)
##### 2.树的子结构
<font color=black size=3 face="微软雅黑">&emsp;&emsp;输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）
> <font color = black size = 3 face  = "微软雅黑">查找A树中是否存在和B树结构一致的子结构，可分为两方面：①在A树中找到和B树的根节点的值一致的节点C②然后判断A树中以C为根节点的子树是否包含和B树一致的结构
>  <font color = black size = 3 face  = "微软雅黑">第一步在A树中查找和B树根节点一致的节点，实质就是树的遍历，鉴于二叉树的结构特点选用递归的方法进行遍历，当找到相应节点后进行第二步处理
>  <font color = black size = 3 face  = "微软雅黑">第二步判断A树中以C节点为根节点的子树中是否包含和B树具有相同的结构，利用递归，若界节点C的值和B树不一致，则返回false，若一致，则递归判断它们各自的左右节点，直至A树或B树的叶节点
```cpp
/*
struct TreeNode {
    int val;
    struct TreeNode *left;
    struct TreeNode *right;
    TreeNode(int x) :
            val(x), left(NULL), right(NULL) {
    }
};*/
class Solution {
public:
    //其次，当找着R后，判断Tree1中以R为跟节点的树和Tree2结构是否相同，以Tree1和Tree2的空节点为限
    bool Tree1hasTree2(TreeNode* p1, TreeNode* p2)
    {
        if (p2 == nullptr)
            return true;
 
        if (p1 == nullptr)
            return false;
 
        if (p1->val != p2->val)
            return false;
 
        return Tree1hasTree2(p1->left, p2->left) && Tree1hasTree2(p1->right, p2->right);
    }
    bool HasSubtree(TreeNode* pRoot1, TreeNode* pRoot2)
    {
        //首先在Root1中查找Root2的根结点相同的节点R
        bool result = false;
 
        if (pRoot1 != nullptr && pRoot2 != nullptr)
        {
            if(pRoot1->val == pRoot2->val)
                result = Tree1hasTree2(pRoot1, pRoot2);
 
            if (!result)
                result = HasSubtree(pRoot1->left, pRoot2);
            if (!result)
                result = HasSubtree(pRoot1->right, pRoot2);
        }
         
        return result;
    }
};
```
```cpp
/*
struct TreeNode {
    int val;
    struct TreeNode *left;
    struct TreeNode *right;
    TreeNode(int x) :
            val(x), left(NULL), right(NULL) {
    }
};*/
class Solution {
public:
    bool HasSubtree(TreeNode* pRoot1, TreeNode* pRoot2) {
        if(pRoot1 == NULL || pRoot2 == NULL) return false;
        if(pRoot1->val == pRoot2->val && MyHasSubtree(pRoot1, pRoot2)) {    // 找到与根相同的结点才往下判断
            return true;
        }
        return HasSubtree(pRoot1->left, pRoot2) || HasSubtree(pRoot1->right, pRoot2);   // 查找A的左右子树是不是含有B树
    }

    bool MyHasSubtree(TreeNode* pRoot1, TreeNode* pRoot2) {
        if(pRoot2 == NULL) return true; // B树匹配到叶子结点了，说明B是A的子结构
        if(pRoot1 == NULL) return false;    // B没到叶子结点，A就已经到了叶子结点，说明B还没匹配完
        if(pRoot1->val == pRoot2->val) {
            return MyHasSubtree(pRoot1->left, pRoot2->left) && MyHasSubtree(pRoot1->right, pRoot2->right);
        }
        return false;
    }
};
```
- [树的子结构](https://www.nowcoder.com/practice/6e196c44c7004d15b1610b9afca8bd88?tpId=13&tqId=11170&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)